import { ColorData } from "../data/ColorData.data.avt";
import { ColorTypes } from "../data/ColorTypes.data.avt";

export class Color {
    private subscribers: Array<Function> = [];
    private currentColor: ColorData;

    public static createFromRgb(r: number, g: number, b: number): Color {
        return new Color(`rgb(${r}, ${g}, ${b})`);
    }

    /**
     * The hex format of the color
     */
    public get hex(): string {
        return this.rgbToHex(this.currentColor.r, this.currentColor.g, this.currentColor.b);
    }
    public set hex(hexString: string) {
        this.currentColor = this.hexStringToRgb(hexString);
        this.emitEvent();
    }


    /**
     * The rgb format of the color
     */
    get rgb() {
        return this.currentColor;
    }
    set rgb(value: ColorData) {
        if(
            typeof value === 'object' &&
            !Array.isArray(value) &&
            value !== null
        ) {
            value.r = Math.min(Math.max(value.r, 0), 255);
            value.g = Math.min(Math.max(value.g, 0), 255);
            value.b = Math.min(Math.max(value.b, 0), 255);
            this.currentColor = value;
            this.emitEvent();
        }
    }

    get r() {
        return this.currentColor.r;
    }
    set r(newValue) {
        if(newValue >= 0 && newValue <= 255) {
            this.currentColor.r = newValue;
            this.emitEvent();
        } else {
            throw new Error("Invalid value");
        }
    }

    get g() {
        return this.currentColor.g;
    }
    set g(newValue) {
        if(newValue >= 0 && newValue <= 255) {
            this.currentColor.g = newValue;
            this.emitEvent();
        } else {
            throw new Error("Invalid value");
        }
    }

    get b() {
        return this.currentColor.b;
    }
    set b(newValue) {
        if(newValue >= 0 && newValue <= 255) {
            this.currentColor.b = newValue;
            this.emitEvent();
        } else {
            throw new Error("Invalid value");
        }
    }

    /**
     * Create a new color
     */
    constructor(colorString: string) {
        let colorType: ColorTypes = this.getColorType(colorString);
        if(colorType !== ColorTypes.unkown) {
            if(colorType === ColorTypes.rgb) {
                this.currentColor = this.stringToRgb(colorString);
            } else if(colorType === ColorTypes.hex) {
                this.currentColor = this.hexStringToRgb(colorString);
            } else if(colorType === ColorTypes.rgba) {
                console.log("Not implemented yet");
            } else {
                throw new Error("Unknown color type");
            }
        } else {
            throw new Error(`${colorString} is not a supported color`);
        }
    }

    private getColorType(colorString: string): ColorTypes {
        let treatedColor = colorString.replaceAll(" ", "");
        if(treatedColor[0] === "#") {
            return ColorTypes.hex;
        } else if(/^rgb\((\d{1,3},*){3}\)$/.test(treatedColor)) {
            return ColorTypes.rgb;
        } else if(/^rgb\((\d{1,3},*){4}\)$/.test(treatedColor)) {
            return ColorTypes.rgba;
        } else {
            console.warn(`Got an unknown color : ${treatedColor}`);
            return ColorTypes.unkown;
        }
    }

    private stringToRgb(rgbColorString): ColorData {
        let splitted = rgbColorString.replaceAll(/[\(\)rgb ]/g, "").split(",");
        for(let i = 0; i < 3; i++) {
            splitted[i] = Math.min(Math.max(parseInt(splitted[i])), 255);
        }
        return {
            r: splitted[0],
            g: splitted[1],
            b: splitted[2]
        };
    }

    private hexStringToRgb(hexColorString): ColorData {
        // source : https://stackoverflow.com/a/5624139
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexColorString = hexColorString.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });

        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColorString);
        if(!result) {
            console.error(`Invalid hex string : ${hexColorString}`);
            return {
                r: 0,
                g: 0,
                b: 0
            };
        } else {
            return {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            };
        }
    }

    private rgbToHex(r, g, b): string {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    private onChange(callback): void {
        if(this.subscribers.indexOf(callback) !== -1) {
            console.error("Callback was already present in the subscribers");
            return;
        }
        this.subscribers.push(callback);
    }
    private offChange(callback): void {
        let index = this.subscribers.indexOf(callback);
        if(index === -1) {
            console.error("Callback was not present in the subscribers");
            return;
        } else {
            this.subscribers.splice(index, 1);
        }
    }
    private emitEvent(): void {
        [...this.subscribers].forEach(subscriber => {
            subscriber(this);
        });
    }
}
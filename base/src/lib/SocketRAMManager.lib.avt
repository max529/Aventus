import { Data } from "../data/Data.data.avt";
import { IRAMManager } from "./RAMManager.lib.avt";
import { Socket } from "./Socket.lib.avt";

export interface SocketRAMManagerObject {
    update(newData: {}): Promise<{}>;
    onUpdate(callback: Function);
    offUpdate(callback: Function);
    delete();
    onDelete(callback: Function);
    offDelete(callback: Function);
    _publish(type, data);
    _subscribers: {
        updated: Function[],
        deleted: Function[];
    };
}

export abstract class SocketRAMManager<T extends Data> implements IRAMManager {
    public static defaultSocketName: string | undefined = undefined;

	public types: { [key: string]: string } = {};
	public options: { definition?: { [key: string]: string } } = {};

	private records: { [primaryKey: number]: (T & SocketRAMManagerObject) };
	private gotAllRecords: boolean;
	private objectProperties: string[];
	private socketActions: { [actionName: string]: string };
	private socketRoutes: { [routeName: string]: { [actionName: string]: string } };
	private subscribers: { [actionName: string]: Function[] };

    private registeredErrorsCallbacks: Function[];

    abstract getObjectName(): string;
    getPrimaryKey(): string {
        return "id";
    }

    private _getSocketName() {
        return SocketRAMManager.defaultSocketName;
    }

	constructor() {
		this.records = {};

		this.socketActions = {
			get: "get",
			getAll: "get/all",
			create: "create",
			created: "created",
			update: "update",
			updated: "updated",
			delete: "delete",
			deleted: "deleted"
		};

		this.gotAllRecords = false;

		this.subscribers = {};
		this.subscribers[this.socketActions.created] = [];
		this.subscribers[this.socketActions.updated] = [];
		this.subscribers[this.socketActions.deleted] = [];

		this.socketRoutes = {};
		for (const [key, name] of Object.entries(this.socketActions)) {
			this.socketRoutes[key] = {
                request: `${this.getObjectName()}/${name}`,
                multiple: `${this.getObjectName()}/${name}/multiple`,
                success: `${this.getObjectName()}/${name}/success`,
                error: `${this.getObjectName()}/${name}/error`
			};
		}

		Socket.getInstance(this._getSocketName()).addRoute({
            channel: this.getObjectName() + "/" + this.socketActions.created,
            callback: response => {
                if (response.data) {
                    for (let key in response.data) {
                        this.addDataToRecords(response.data[key]);
                        this.publish(this.socketActions.created, this.records[response.data[key][this.getPrimaryKey()]]);
                    }
                }
            }
		});

		Socket.getInstance(this._getSocketName()).addRoute({
			channel: this.getObjectName() + "/" + this.socketActions.updated,
			callback: response => {
				if (response.data) {
                    for (let key in response.data) {
                        const newData = response.data[key];
                        const primaryKey = newData[this.getPrimaryKey()];

                        if (this.records[primaryKey]) {
                            const record = this.records[primaryKey];
                            this.updateInstanceData(record, newData);

                            this.addMemoryRecord(record);
                            record._publish(this.socketActions.updated, record);
                            this.publish(this.socketActions.updated, record);

                        }
                    }
                }
			}
		});

        Socket.getInstance(this._getSocketName()).addRoute({
            channel: this.getObjectName() + "/" + this.socketActions.deleted,
            callback: response => {
                if (response.data) {
                    for (let key in response.data) {
                        const data = response.data[key];
                        const primaryKey = data[this.getPrimaryKey()];
                        if (this.records.hasOwnProperty(primaryKey)) {
                            const record = this.records[primaryKey];
                            this.deleteMemoryRecord(primaryKey);
                            record._publish(this.socketActions.deleted, record);
                            this.publish(this.socketActions.deleted, record);

                        }
                    }
                }
            }
        });
	}

    addErrorListener(callback) {
        this.registeredErrorsCallbacks.push(callback);
    }

    triggerError(...args:any[]) {
        this.registeredErrorsCallbacks.forEach(callback => {
            callback(...args);
        });
    }

	getAll(): Promise<(T & SocketRAMManagerObject)[]> {
        return new Promise((resolve, reject) => {
            if (this.gotAllRecords) {
                let toReturn = [];
                for (let key in this.records) {
                    toReturn.push(this.records[key]);
                }
                resolve(toReturn);
            } else {
                Socket.getInstance(this._getSocketName()).sendMessageAndWait(this.socketRoutes.getAll.request, {}, {
                    [this.socketRoutes.getAll.success]: response => {
                        if (response.data) {
                            this.gotAllRecords = true;
                            resolve(this.addDataToRecords(Object.values(response.data)));
                        }
                    }
                });
            }
        });
    }

	get(id: number, forceRefresh: boolean = false): Promise<T & SocketRAMManagerObject> {
		return new Promise((resolve, reject) => {
			if (this.records[id] && !forceRefresh) {
                resolve(this.records[id]);
            } else {
                Socket.getInstance(this._getSocketName()).sendMessageAndWait(this.socketRoutes.get.request, {
                    [this.getPrimaryKey()]: id
                }, {
                    [this.socketRoutes.get.success]: response => {
                        if (response.data) {
                            if (forceRefresh) {
                                delete this.records[id];
                            }

                            this.addDataToRecords(response.data, resolve);
                        }
                    },
                    [this.socketRoutes.get.error]: response => {
                        this.printErrors(response, "delete");
                        reject(response);
                    }
                });
            }
		});
	}

	getMultiple(ids: number[]): Promise<(T & SocketRAMManagerObject)[]> {
		return new Promise((resolve, reject) => {
            let datas: (T & SocketRAMManagerObject)[] = [];
            let missingIds: number[] = [];
            for (let i = 0; i < ids.length; i++) {
                let id = ids[i];
                if (this.records[id]) {
                    datas.push(this.records[id]);
                } else {
                    missingIds.push(id);
                }
            }
            if (missingIds.length > 0) {
                Socket.getInstance(this._getSocketName()).sendMessageAndWait(this.socketRoutes.get.multiple, {
                    [this.getPrimaryKey()]: ids
                }, {
                    [this.socketRoutes.get.success]: response => {
                        if (response.data) {
                            this.addDataToRecords(response.data, (record) => {
                                datas.push(record)
                                resolve(record);
                            }, (data) => {
                                datas.push(data);
                            });
                        }
                    },
                    [this.socketRoutes.get.error]: response => {
                        this.printErrors(response, "delete");
                        reject(response);
                    }
                });
            } else {
                resolve(datas);
            }
        });
	}

	create(data: T|T[], cbError?: Function): Promise<T & SocketRAMManagerObject> {
		const multiple = this.isDataContainsMultipleRecords(data);
        let dataToSend: T|{ list: T[] } = this.manageMultipleRecords(data);

        if (cbError == null) {
            cbError = (response) => { this.printErrors(response, "creation"); }
        }

        return new Promise((resolve, reject) => {
            this.convertDefinitionToData(dataToSend);
            let routeName = multiple ? this.socketRoutes.create.multiple : this.socketRoutes.create.request;

            Socket.getInstance(this._getSocketName()).sendMessageAndWait(routeName, dataToSend, {
                [this.socketRoutes.create.success]: response => {
                    response = this.formatResponse(response, this.socketActions.create);
                    this.addDataToRecords(response, (record) => {
                        console.warn("The object return by the created success was already in records. Record data : ", record);
                    }, (data) => {
                        this.publish(this.socketActions.created, data);
                    });
                    resolve(multiple ? response : response[0]);
                },
                [this.socketRoutes.create.error]: response => {
                    cbError(response)
                    reject(response);
                }
            });
        });
	}

    update(data: T|T[], cbError?: Function): Promise<T & SocketRAMManagerObject> {
        const multiple = this.isDataContainsMultipleRecords(data);
        let dataToSend: T|{ list: T[] } = this.manageMultipleRecords(data);

        if (cbError == null) {
            cbError = (response) => { this.printErrors(response, "save"); }
        }

        return new Promise((resolve, reject) => {
            this.convertDefinitionToData(dataToSend);
            let routeName = multiple ? this.socketRoutes.update.multiple : this.socketRoutes.update.request;

            Socket.getInstance(this._getSocketName()).sendMessageAndWait(routeName, dataToSend, {
                [this.socketRoutes.update.success]: response => {
                    response = this.formatResponse(response, this.socketActions.update);

                    if (multiple) {
                        data = (dataToSend as { list: T[] }).list;
                    }

                    response.forEach((newData) => {
                        const index = newData[this.getPrimaryKey()];

                        if (!this.records[index]) {
                            this.addDataToRecords(response);
                        }

                        this.updateInstanceData(this.records[index], newData);
                        this.addMemoryRecord(this.records[index]);
                        this.records[index]._publish(this.socketActions.updated, this.records[index]);
                    });
                    resolve(multiple ? data : data[0]);
                },
                [this.socketRoutes.update.error]: response => {
                    cbError(response);
                    reject(response);
                }
            });
        });
    }

    delete(data: T|T[], cbError?: Function): Promise<T & SocketRAMManagerObject> {
        const multiple = this.isDataContainsMultipleRecords(data);
        let dataToSend: T|{ list: T[] } = this.manageMultipleRecords(data);

        if (cbError == null) {
            cbError = (response) => { this.printErrors(response, "delete"); }
        }

        return new Promise((resolve, reject) => {
            this.convertDefinitionToData(dataToSend);
            let routeName = multiple ? this.socketRoutes.delete.multiple : this.socketRoutes.delete.request;

            Socket.getInstance(this._getSocketName()).sendMessageAndWait(routeName, dataToSend, {
                [this.socketRoutes.delete.success]: response => {
                    response = this.formatResponse(response, this.socketActions.delete);

                    if (multiple) {
                        data = (dataToSend as { list: T[] }).list;
                    }

                    response.forEach((object, index) => {
                        this.records[object[this.getPrimaryKey()]]._publish(this.socketActions.deleted, this.records[object[this.getPrimaryKey()]]);
                        this.deleteMemoryRecord(object[this.getPrimaryKey()]);
                    });
                    resolve(multiple ? data : data[0]);
                },
                [this.socketRoutes.delete.error]: response => {
                    cbError(response);
                    reject(response);
                }
            });
        });
    }

    subscribeMultiple(callback: Function, types: string[] = [this.socketActions.created, this.socketActions.updated, this.socketActions.deleted]) {
        types.forEach(type => {
            this.addSubscriber(type, callback);
        });
    }

    unsubscribeMultiple(callback: Function, types: string[] = [this.socketActions.created, this.socketActions.updated, this.socketActions.deleted]) {
        types.forEach(type => {
            this.removeSubscriber(type, callback);
        });
    }

    subscribe(callback: Function) {
        this.addSubscriber(this.socketActions.created, callback);
    }

    unsubscribe(callback: Function) {
        this.removeSubscriber(this.socketActions.created, callback);
    }

    onUpdated(callback: Function) {
        this.addSubscriber(this.socketActions.updated, callback);
    }

    offUpdated(callback: Function) {
        this.removeSubscriber(this.socketActions.updated, callback);
    }

    onDeleted(callback: Function) {
        this.addSubscriber(this.socketActions.deleted, callback);
    }

    offDelete(callback: Function) {
        this.removeSubscriber(this.socketActions.deleted, callback);
    }

    private addSubscriber(type: string, callback: Function) {
        const index = this.subscribers[type].indexOf(callback);
        if (index === -1) {
            this.subscribers[type].push(callback);
        } else {
            console.warn(`[${this.getObjectName()} Manager] Trying to subscribe to ${type} but callback was already present`);
        }
    }

    private removeSubscriber(type: string, callback: Function) {
        const index = this.subscribers[type].indexOf(callback);
        if (index !== -1) {
            this.subscribers[type].splice(index, 1);
        }
    }

    private printErrors(data: { status: number, errors?: [{ code: number, description: string }] }, action: string) {
        this.triggerError(data, action);
    }

    private publish(type: string, data: T & SocketRAMManagerObject) {
        [...this.subscribers[type]].forEach(callback => callback(data));
	}

    private addDatabaseOperationsToRecord(data: T): T & SocketRAMManagerObject {
        this.updateObjectProperties(data);

        const instance: T & SocketRAMManagerObject = {
            ...data,
            _subscribers: {
                updated: [],
                deleted: []
            },
            _publish: (type: string, data: T & SocketRAMManagerObject) => {
                [...instance._subscribers[type]].forEach(callback => callback(data));
                this.publish(type, data);
            },
            update: (newData: T): Promise<T & SocketRAMManagerObject> => {
                return new Promise((resolve, reject) => {
                    const formattedData = { ...instance, ...newData };
                    this.convertDefinitionToData(formattedData);

                    Socket.getInstance(this._getSocketName()).sendMessageAndWait(this.socketRoutes.update.request, formattedData, {
                        [this.socketRoutes.update.success]: response => {
                            response = this.formatResponse(response, this.socketActions.update);
                            this.updateInstanceData(instance, response[0]);

                            this.addMemoryRecord(instance);
                            instance._publish(this.socketActions.updated, instance);
                            resolve(instance);
                        },
                        [this.socketRoutes.update.error]: response => {
                            this.printErrors(response, "update");
                            reject(response);
                        }
                    });
                });
            },
            onUpdate: (callback: Function) => {
                if (!callback) {
                    console.error("[Object Manager] onUpdate callback is undefined");
                    return;
                }
                instance._subscribers.updated.push(callback);
            },
            offUpdate: (callback: Function) => {
                let index = instance._subscribers.updated.indexOf(callback);
                if (index !== -1) {
                    instance._subscribers.updated.splice(index, 1);
                }
            },
            delete: (): Promise<T & SocketRAMManagerObject> => {
                return new Promise((resolve, reject) => {
                    this.convertDefinitionToData(instance);
                    Socket.getInstance(this._getSocketName()).sendMessageAndWait(this.socketRoutes.delete.request, instance, {
                        [this.socketRoutes.delete.success]: response => {
                            response = this.formatResponse(response, this.socketActions.delete);
                            this.deleteMemoryRecord(response[0][this.getPrimaryKey()]);
                            instance._publish(this.socketActions.deleted, instance);
                            resolve(instance);
                        },
                        [this.socketRoutes.delete.error]: response => {
                            this.printErrors(response, "delete");
                            reject(response);
                        }
                    });
                });
            },
            onDelete: (callback: Function) => {
                instance._subscribers.deleted.push(callback);
            },
            offDelete: (callback: Function) => {
                let index = instance._subscribers.deleted.indexOf(callback);
                if (index !== -1) {
                    instance._subscribers.deleted.splice(index, 1);
                }
            }
        };
        this.addMemoryRecord(instance);

        return instance;
	}

    private formatResponse(response, action: string) {
        if (action === this.socketActions.create) {
            response = Object.values(response.created);
        } else if (action === this.socketActions.update) {
            response = Object.values(response.updated);
        } else if (action === this.socketActions.delete) {
            response = Object.values(response.deleted);
        }

        return response;
    }

    private addDataToRecords(data: T|T[], ifExistFct?: Function, ifNotExistFct?: Function): (T & SocketRAMManagerObject)[] {
        if (!Array.isArray(data)) {
            data = [data];
        }

        if (!ifNotExistFct) {
            ifNotExistFct = ifExistFct;
        }

		let toReturn = [];
        data.forEach(record => {
            if (!this.records[record[this.getPrimaryKey()]]) {
				let instance: T & SocketRAMManagerObject = this.addDatabaseOperationsToRecord(record);
                this.records[record[this.getPrimaryKey()]] = instance;
                toReturn.push(instance);
                ifNotExistFct(instance);
            } else {
                toReturn.push(this.records[record[this.getPrimaryKey()]]);
                ifExistFct(this.records[record[this.getPrimaryKey()]]);
            }
        });

        return toReturn;
	}

    private addMemoryRecord(record: T & SocketRAMManagerObject) {
        const primaryKey = record[this.getPrimaryKey()];
        this.convertDataToDefinition(record);

        this.records[primaryKey] = record;
    }

    private deleteMemoryRecord(recordId: number) {
        delete this.records[recordId];
    }

    private convertDataToDefinition(data: T & SocketRAMManagerObject) {
        const realData = { ...data };

        if (!this.options.definition) {
            return;
        }

        for (const [key, value] of Object.entries(this.options.definition)) {
            data[value] = realData[key];
            delete data[key];
        }
    }

	private convertDefinitionToData(data: T|{ list: T[] }) {
        const _convertDefinition = data => {
            const definition = { ...data };

            if (!this.options.definition) {
                return;
            }

            for (const [key, value] of Object.entries(this.options.definition)) {
                if (definition[value]) {
                    data[key] = definition[value];
                } else {
                    delete data[key];
                }
                delete data[value];
            }

            delete data.update;
            delete data.onUpdate;
            delete data.offUpdate;
            delete data.delete;
            delete data.onDelete;
            delete data.offDelete;
        };

        if ((data as { list: T[] }).list) {
            (data as { list: T[] }).list.forEach(object => _convertDefinition(object));
        } else {
            _convertDefinition(data);
        }
    }

    private updateObjectProperties(data: T) {
        Object.keys(data).forEach(key => {
            if (!this.objectProperties.includes(key)) {
                this.objectProperties.push(key);
            }
        });
    }

    private updateInstanceData(currentInstance: T & SocketRAMManagerObject, newData: T) {
        this.updateObjectProperties(newData);

        for (const [key, value] of Object.entries(newData)) {
            currentInstance[key] = value;
        }

        this.objectProperties.forEach(key => {
            if (currentInstance[key] !== undefined && newData[key] === undefined) {
                delete currentInstance[key];
            }
        });
    }

	private manageMultipleRecords(data: T|T[]): (T|{ list: T[] }) {
        let toReturn: T|{ list: T[] };
        if (this.isDataContainsMultipleRecords(data)) {
            toReturn = { list: data as T[] };
        }

        return toReturn;
    }
	
	private isDataContainsMultipleRecords(data) {
        return Array.isArray(data);
    }    
}
import { PressManager } from "../../lib/PressManager.lib.avt";
import { DefaultComponent, WebComponent } from "../../lib/WebComponent.lib.avt";
import { AvHideableOptions } from "./hideableOptions.lib.avt";

export class AvHideable extends WebComponent implements DefaultComponent {

    //#region static

    //#endregion


    //#region props

    //#endregion


    //#region variables
    private oldParent: HTMLElement = undefined;
    @mutable((target: AvHideable) => {
        target.dispatchEvent(new CustomEvent("toggleVisibility", { detail: { visible: target.isVisible } }));
    })
    private isVisible: boolean = false;
    private options: AvHideableOptions;
    private checkCloseBinded: (e: Event) => {};
    private pressManager: PressManager;
    content: HTMLDivElement;
    //#endregion


    //#region states

    //#endregion


    //#region constructor
    constructor() {
        super();
        this.options = {
            noHideItems: [this],
            container: document.body,
            beforeHide: this.defaultBeforeHide,
            afterHide: this.defaultAfterHide,
            canHide: this.defaultCanHide
        };

        this.checkCloseBinded = this.checkClose.bind(this);
    }
    //#endregion


    //#region methods
    private async defaultBeforeHide() { }
    private async defaultAfterHide() { }
    private async defaultCanHide(): Promise<boolean> { return true; }
    configure(options: AvHideableOptions) {
        if(options.noHideItems) {
            this.options.noHideItems = options.noHideItems;
        }
        if(options.beforeHide) {
            this.options.beforeHide = options.beforeHide;
        }
        if(options.afterHide) {
            this.options.afterHide = options.afterHide;
        }
        if(options.canHide) {
            this.options.canHide = options.canHide;
        }
        if(options.container) {
            this.options.container = options.container;
        }
    }
    show() {
        if(this.isVisible) {
            return;
        }
        this.isVisible = true;
        this.oldParent = this.parentNode as HTMLElement;
        if(this.shadowRoot.querySelector("style").innerText.indexOf(":host{--inserted: \"here\"}") != -1) {
            // insert style from
            let newStyle = "";

            const parentShadowRoot = this.oldParent.findParentByType(ShadowRoot);
            if(parentShadowRoot instanceof ShadowRoot) {
                let matchingArr = parentShadowRoot.querySelector("style").innerText.match(/av-hideable.*?\{.*?\}/g);
                if(matchingArr) {
                    newStyle = matchingArr.join("").replace(/av-hideable/g, ":host");
                }
            }
            this.shadowRoot.querySelector("style").innerText = this.shadowRoot.querySelector("style").innerText.replace(":host{--inserted: \"here\"}", newStyle);
        }
        this.loadCSSVariables();

        this.style.display = 'block';
        this.options.container.appendChild(this);
        this.options.container.addEventListener("pressaction_trigger", this.checkCloseBinded);
        this.pressManager = new PressManager({
            element: this.options.container,
            onPress: (e) => {
                this.checkCloseBinded(e);
            }
        });

    }
    private loadCSSVariables() {
        let styleSheets = this.shadowRoot.styleSheets;
        let realStyle = getComputedStyle(this);
        let propsToAdd = {};
        for(let i = 0; i < styleSheets.length; i++) {
            let rules = styleSheets[i].cssRules;
            for(let j = 0; j < rules.length; j++) {
                for(let indexTxt in rules[j]["style"]) {
                    let index = Number(indexTxt);
                    if(isNaN(index)) {
                        break;
                    }
                    let prop = rules[j]["style"][index];
                    let value = rules[j]["style"][prop];
                    if(value.startsWith("var(")) {
                        let varToDef = value.match(/var\(.*?(\,|\))/g)[0].replace("var(", "").slice(0, -1);
                        let realValue = realStyle.getPropertyValue(varToDef);
                        propsToAdd[varToDef] = realValue.trim();
                    }
                }
            }
        }
        for(let key in propsToAdd) {
            this.style.setProperty(key, propsToAdd[key]);
        }

    }

    async hide(force?: boolean) {
        if(this.isVisible) {
            if(force || await this.options.canHide()) {
                await this.options.beforeHide();
                this.isVisible = false;
                this.style.display = 'none';
                this.oldParent.appendChild(this);
                this.options.container.removeEventListener("pressaction_trigger", this.checkCloseBinded);
                this.pressManager.destroy();
                await this.options.afterHide();
            }
        }
    }

    private checkClose(e: Event) {
        var realTargetEl = e.realTarget();
        for(var i = 0; i < this.options.noHideItems.length; i++) {
            if(this.options.noHideItems[i].containsChild(realTargetEl)) {
                return;
            }
        }
        this.hide();
    }


    protected override postCreation(): void {
        var listChild = this.getElementsInSlot<HTMLElement>();
        for(let i = 0; i < listChild.length; i++) {
            this.content.appendChild(listChild[i]);
        }
    }
	//#endregion
}
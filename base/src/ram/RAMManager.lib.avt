export abstract class AvGenericRAMManager<T extends IRAMManager, U, R extends U> implements IRAMManager {
    private static allRams: { [key: string]: IRAMManager; } = {};

    protected static _getInstance<T extends IRAMManager>(): T {
        if(!this.allRams.hasOwnProperty(this.name)) {
            let temp: any = { class: this };
            this.allRams[this.name] = new temp["class"]();
        }
        return this.allRams[this.name] as T;
    }

    private records: { [key: number]: R; };

    public abstract getPrimaryKey(): string;

    private getId(item: U): string | undefined {
        if(item[this.getPrimaryKey()] !== undefined) {
            return item[this.getPrimaryKey()] + "";
        }
        console.error("can't found key " + this.getPrimaryKey() + " inside ", item);
        return undefined;
    }
    protected constructor() {
        if(this.constructor == RAMManager) {
            throw "can't instanciate an abstract class";
        }
        this.records = {};
    }

    protected abstract transformInToOut(item: U): R;
    //#region add
    async addList(list: U[]): Promise<R[]> {
        let result: R[] = [];
        await this.beforeAddList(list);
        for(let item of list) {
            let resultItem = await this.add(item);
            if(resultItem) {
                result.push(resultItem);
            }
        }
        await this.afterAddList(result);
        return result;
    }
    async add(item: U): Promise<R | undefined> {
        let key = this.getId(item);
        if(key) {
            let createdItem = this.transformInToOut(item);
            await this.beforeAddItem(createdItem);
            this.records[key] = createdItem;
            await this.afterAddItem(createdItem);
            return createdItem;
        }
        return undefined;
    }
    async beforeAddList(list: U[]): Promise<void> { }
    async beforeAddItem(item: R): Promise<void> { }
    async afterAddItem(item: R): Promise<void> { }
    async afterAddList(list: R[]): Promise<void> { }
    //#endregion

    //#region update
    updateList(list: U[]) {
        this.beforeUpdateList(list);
        for(let item of list) {
            this.update(item);
        }
        this.afterUpdateList(list);
    }
    update(item: U) {
        let key = this.getId(item);
        if(key) {
            if(this.records[key]) {
                this.beforeUpdateItem(item);
                // TODO do this to found update field for Proxy element, but must find a better way to do that
                // this.records[key] = {
                //     ...this.records[key],
                //     ...item
                // };
                this.records[key] = item;
                this.afterUpdateItem(item);
            }
            else {
                console.error("can't update the item " + key + " because it wasn't found inside ram");
            }

        }
    }
    beforeUpdateList(list: U[]) { }
    beforeUpdateItem(item: U) { }
    afterUpdateItem(item: U) { }
    afterUpdateList(list: U[]) { }
    //#endregion

    //#region delete
    deleteList(list: U[]) {
        this.beforeDeleteList(list);
        for(let item of list) {
            this.delete(item);
        }
        this.afterDeleteList(list);
    }
    delete(item: U) {
        let key = this.getId(item);
        if(key && this.records[key]) {
            let oldItem = this.records[key];
            this.beforeDeleteItem(oldItem);
            delete this.records[key];
            this.afterDeleteItem(oldItem);
        }
    }
    beforeDeleteList(list: U[]) { }
    beforeDeleteItem(item: U) { }
    afterDeleteItem(item: U) { }
    afterDeleteList(list: U[]) { }
    //#endregion

    //#region get
    async getById(id: number): Promise<R> {
        if(this.records[id]) {
            return this.records[id];
        }
        return undefined;
    }
    async getByIds(ids:number[]):Promise<R[]> {
        
    }
    async getAll(): Promise<{ [primaryKey: number]: R; }> {
        return this.records;
    }
    async getList(): Promise<U[]> {
        let data = await this.getAll();
        return Object.values(data);
    }
    //#endregion
}

export abstract class AvRAMManager<T extends IRAMManager, U> extends AvGenericRAMManager<T, U, U>{
    protected transformInToOut(item: U): U {
        return item;
    }

}
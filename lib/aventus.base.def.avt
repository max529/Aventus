// region js //
interface State {    active?: (activeState: string) => void;    inactive?: (oldState: string, nextState: string) => void;    askChange?: (activeState: string, nextState: string) => boolean;    getSlug?: () => string;}interface States {    [key: string]: State;}declare class StateManager {    logLevel: number;    _activeState: any;    _activeParams: any;    _activeSlug: any;    _callbackList: {};    _subscribersMutliple: {};    _subscribers: {};    _isNumberRegex: {};    _callbackFunctions: {};    private constructor();    private static __instances;    static getInstance(name?: string): StateManager;    subscribe(state: string | string[], callbacks: State): void;    /**     *     * @param {string|Array} state - The state(s) to unsubscribe from     * @param {Object} callbacks     * @param {activeCallback} [callbacks.active]     * @param {incativeCallback} [callbacks.inactive]     * @param {askChangeCallback} [callbacks.askChange]     */    unsubscribe(state: any, callbacks: any): void;    /**     * Format a state and return if you need to bypass the test or not     * @param {string} string - The state to format     * @returns {Object} - The state, the formated state and if it's a regex state or not     */    _prepareStateString(string: any): {        state: any;        stateToTest: any;        bypassTest: boolean;    };    /**     * Escape a string to be regex-compatible ()     * @param {string} string The string to escape     * @returns An escaped string     */    _escapeRegExp(string: any): any;    /**     * Get the slug from a state string     * @param {string} state The state to extract the slug from     * @returns {string|undefined} The slug of the state or undefined if the state don't have one     */    _getSlugFromState(state: any): any;    /**     * Save the current info (state/params) in cache     */    _saveDataInCache(): void;    /**     * Add a callback to a key     * @param {string} key - The key to trigger to trigger the function     * @param {function} callback - The function to trigger     */    addFunction(key: any, callback: any): void;    /**     * Remove a function from a key     * @param {string} key - The key to remove the function from     * @param {function} callback - The function to remove     */    removeFunction(key: any, callback: any): void;    /**     * Trigger all the functions added under a key     * @param {string} key - The key to trigger     * @param {*} [params] - The params to pass to the functions (optional)     */    triggerFunction(key: any, params?: {}): void;    /**     * Remove all the function added under all keys     */    clearFunctions(): void;    /**     * Set the current active state     * @param {string} state - The state to set to active     * @param {number} slug - The slug of the active state (Only work if the state ends with "*")     * @param {Object} params - The params of the active state     */    setActiveState(state: any, params?: {}): void;    /**     * Get the active state     * @returns {string} - The active state     */    getActiveState(): any;    /**     * Get the active params     * @returns {Object} - The active params     */    getActiveParams(): any;    /**     * Get the active slug     * @returns {int} - The active slug     */    getActiveSlug(): any;    /**     * Check if a state is in the subscribers and active, return true if it is, false otherwise     * @param {string} state - The state to test     * @returns {boolean} - True if the state is in the subscription list and active, false otherwise     */    isStateActive(state: any): boolean;    _log(logMessage: any, type: any): void;}
interface SocketRAMManagerObject {    update(newData: {}): Promise<{}>;    onUpdate(callback: Function): any;    offUpdate(callback: Function): any;    delete(): any;    onDelete(callback: Function): any;    offDelete(callback: Function): any;    _publish(type: any, data: any): any;    _subscribers: {        updated: Function[];        deleted: Function[];    };}declare abstract class SocketRAMManager<T extends Data> implements IRAMManager {    types: {        [key: string]: string;    };    options: {        definition?: {            [key: string]: string;        };    };    private records;    private gotAllRecords;    private objectProperties;    private socketActions;    private socketRoutes;    private subscribers;    private registeredErrorsCallbacks;    abstract getObjectName(): string;    getPrimaryKey(): string;    private _getSocketName;    constructor();    addErrorListener(callback: any): void;    triggerError(...args: any[]): void;    getAll(): Promise<(T & SocketRAMManagerObject)[]>;    get(id: number, forceRefresh?: boolean): Promise<T & SocketRAMManagerObject>;    getMultiple(ids: number[]): Promise<(T & SocketRAMManagerObject)[]>;    create(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    update(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    delete(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    subscribeMultiple(callback: Function, types?: string[]): void;    unsubscribeMultiple(callback: Function, types?: string[]): void;    subscribe(callback: Function): void;    unsubscribe(callback: Function): void;    onUpdated(callback: Function): void;    offUpdated(callback: Function): void;    onDeleted(callback: Function): void;    offDelete(callback: Function): void;    private addSubscriber;    private removeSubscriber;    private printErrors;    private publish;    private addDatabaseOperationsToRecord;    private formatResponse;    private addDataToRecords;    private addMemoryRecord;    private deleteMemoryRecord;    private convertDataToDefinition;    private convertDefinitionToData;    private updateObjectProperties;    private updateInstanceData;    private manageMultipleRecords;    private isDataContainsMultipleRecords;}
declare class Socket {    private options;    private waitingList;    private multipltWaitingList;    private onDone;    private timeoutError;    private memoryBeforeOpen;    private nbClose;    private socket;    protected constructor();    init(options?: SocketOptions): void;    private static __instances;    static getInstance(name?: string): Socket;    addRoute(newRoute: SocketRoute): void;    /**     * The route to remove     * @param route - The route to remove     */    removeRoute(route: SocketRoute): void;    open(done?: Function, error?: Function): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param options the options to add to the message (typically the uid)     */    sendMessage<T>(channelName: string, data?: T, options?: {}): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWait<T>(channelName: string, data: T, callbacks: {        [key: string]: (data: any) => void;    }): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWaitMultiple(channelName: string, data: {}, callbacks: {}): void;    isReady(): boolean;    private onOpen;    private onError;    private onClose;    private onMessage;    private log;}
interface ResourceLoaderOptions {    url: string;    success?: (data: any) => void;    error?: (error: any) => void;}declare class ResourceLoader {    private static waitingResources;    static load(options: ResourceLoaderOptions, preventCache?: boolean): void;}
interface ResizeObserverOptions {    callback: CallableFunction;    fps?: number;}declare class AvResizeObserver {    private callback;    private targets;    private fpsInterval;    private nextFrame;    private entriesChangedEvent;    private willTrigger;    private static resizeObserverClassByObject;    private static uniqueInstance;    private static getUniqueInstance;    constructor(options: ResizeObserverOptions | CallableFunction);    observe(target: Element): void;    unobserve(target: Element): void;    disconnect(): void;    entryChanged(entry: any): void;    triggerCb(): void;    _triggerCb(): void;}
interface IRAMManager {}declare abstract class RAMManager<T extends IRAMManager, U> implements IRAMManager {    private static allRams;    protected static _getInstance<T extends IRAMManager>(): T;    private records;    abstract getPrimaryKey(): string;    private getId;    protected constructor();    addList(list: U[]): void;    add(item: U): void;    beforeAddList(list: U[]): void;    beforeAddItem(item: U): void;    afterAddItem(item: U): void;    afterAddList(list: U[]): void;    updateList(list: U[]): void;    update(item: U): void;    beforeUpdateList(list: U[]): void;    beforeUpdateItem(item: U): void;    afterUpdateItem(item: U): void;    afterUpdateList(list: U[]): void;    deleteList(list: U[]): void;    delete(item: U): void;    beforeDeleteList(list: U[]): void;    beforeDeleteItem(item: U): void;    afterDeleteItem(item: U): void;    afterDeleteList(list: U[]): void;    getById(id: number): U;    getAll(): {        [primaryKey: number]: U;    };    getList(): U[];}
interface Pointer {    id: number;    constructor(nativePointer: Touch | PointerEvent): any;}interface PressManagerEvent extends MouseEvent {    details?: {        element: Element;        pointerEvent: PointerEvent;    };}interface InternalCustomFunction {    src?: PressManager;    onDrag?: (e: MouseEvent, self: PressManager) => void;    onDragEnd?: (e: MouseEvent, self: PressManager) => void;}interface InternalPointerEvent extends Event {    detail: {        state: PressManagerState;        customFcts: InternalCustomFunction;        realEvent: PointerEvent;    };}interface PressManagerOptions {    element: Element | Element[];    onPress?: (e: PressManagerEvent, self: PressManager) => void;    onLongPress?: (e: MouseEvent, self: PressManager) => void;    onDblPress?: (e: MouseEvent, self: PressManager) => void;    onDrag?: (e: MouseEvent, self: PressManager) => void;    onDragStart?: (e: MouseEvent, self: PressManager) => void;    onDragEnd?: (e: MouseEvent, self: PressManager) => void;    offsetDrag?: number;    delayDblPress?: number;    delayLongPress?: number;}interface PressManagerState {    oneActionTriggered: boolean;    isMoving: boolean;}declare class PressManager {    private options;    private element;    private subPressManager;    private delayDblPress;    private delayLongPress;    private nbPress;    private offsetDrag;    private state;    private startPosition;    private customFcts;    private timeoutDblPress;    private timeoutLongPress;    private downEventSaved;    private functionsBinded;    /**     * @param {*} options - The options     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage     */    constructor(options: PressManagerOptions);    private checkDragConstraint;    private assignValueOption;    private bindAllFunction;    private init;    private downAction;    private upAction;    private moveAction;    private childPress;    private childDblPress;    private childLongPress;    private childDragStart;    private emitTriggerFunction;    destroy(): void;}
declare class PointerTracker {    private element;    private currentPointers;    private startCallback;    private moveCallback;    private endCallback;    private lastEvent;    constructor(element: any, callbacks: any);    reset(): void;    private createPointer;    private triggerPointerStart;    private pointerStart;    private touchStart;    private move;    private triggerPointerEnd;    private pointerEnd;    private touchEnd;    private isTooOld;}

interface SocketMessage {    channel: string;    data?: any;}interface SocketRoute {    channel: string;    callback: (data: any) => void;}interface SocketOptions {    log?: boolean;    ip?: string;    port?: number;    useHttps?: boolean;    routes?: {        [key: string]: SocketRoute[];    };    socketName?: string;    onOpen?: () => void;    onError?: () => void;    onClose?: () => void;}interface ISocket {    init(options: SocketOptions): any;    addRoute(newRoute: SocketRoute): any;    /**     * The route to remove     * @param route - The route to remove     */    removeRoute(route: SocketRoute): any;    open(done: () => void, error: () => void): any;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param options the options to add to the message (typically the uid)     */    sendMessage<T>(channelName: string, data: T, options: any): any;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWait<T>(channelName: string, data: T, callbacks: {        [key: string]: (data: any) => void;    }): any;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWaitMultiple(channelName: string, data: {}, callbacks: {}): any;    isReady(): boolean;}
interface HttpRequestOptions {    url: string;    method?: HttpRequestMethod;    data?: {        [key: string]: any;    } | FormData;}declare class DefaultHttpRequestOptions implements HttpRequestOptions {    url: string;    method: HttpRequestMethod;}declare class HttpRequest {    private _options;    private _url;    static getMethod(method: string): HttpRequestMethod;    private getMethod;    constructor(options: HttpRequestOptions);    send(): any;}declare enum HttpRequestMethod {    GET = 0,    POST = 1,    DELETE = 2,    PUT = 3,    OPTION = 4}
declare interface ObjectConstructor {
    transformIntoWatcher: (obj, onDataChanged) => any;
    prepareByPath:(obj, path, currentPath?) => {canApply:boolean, objToApply:any};
    isPathMatching:(p1:string, p2:string) => void;
}
declare interface Event {
    normalize: () => void;
    /**
     * Cancel event and create a clone trigger on body : used for popup etc
     */
    cancelEvent:() => void;
    /**
     * Real element target on an event
     */
    realTarget:() => Element;
}
declare interface Element {
    findParentByTag<T>(tagname:string|string[], untilNode?:Element) => T | null;
    findParents<T>(tagname:string|string[], untilNode?:Element) => T[];
    findParentByClass<T>(classname:string|string[]) => T | null;
    containsChild(el:Element) => boolean;
    getPositionOnScreen:(untilEl?:HTMLElement) => {
        top: top,
        left: left
    };
    getElementsInSlot<T>:() => T[];
}
declare interface Date {
    clone: () => Date;
}
declare interface Array<T> {
    unique: () => Array<T>;
	last:() => T; 
}
declare class Color {    private subscribers;    private currentColor;    static createFromRgb(r: number, g: number, b: number): Color;    /**     * The hex format of the color     */    get hex(): string;    set hex(hexString: string);    /**     * The rgb format of the color     */    get rgb(): ColorData;    set rgb(value: ColorData);    get r(): any;    set r(newValue: any);    get g(): any;    set g(newValue: any);    get b(): any;    set b(newValue: any);    /**     * Create a new color     */    constructor(colorString: string);    private getColorType;    private stringToRgb;    private hexStringToRgb;    private rgbToHex;    private onChange;    private offChange;    private emitEvent;}
interface AnimationOptions {    animate?: Function;    stopped?: Function;    fps?: number;}declare class AnimationManager {    static baseFps: number;    private options;    private nextFrame;    private fpsInterval;    private continueAnimation;    constructor(options: AnimationOptions);    private animate;    /**     * Start the of animation     */    start(): void;    /**     * Stop the animation     */    stop(): void;    /**     * Get the FPS     *     * @returns {number}     */    getFPS(): number;    /**     * Set the FPS     *     * @param fps     */    setFPS(fps: number): void;    /**     * Get the animation status (true if animation is running)     *     * @returns {boolean}     */    isStarted(): boolean;}
interface DebuggerConfig {    writeCompiled?: boolean;}interface DefaultComponent {    states?: States;    [key: string]: any;    getStateManagerName?(): string | undefined;}declare class WebComponent extends HTMLElement implements DefaultComponent {    static get observedAttributes(): {};    private _first;    private _isReady;    get isReady(): boolean;    private _translations;    private currentState;    private statesList;    private _components;    private __onChangeFct;    private getSlugFct;    private __mutable;    private __mutableActions;    private __prepareForCreate;    private __prepareForUpdate;    private __loopTemplate;    private __mutableActionsCb;    constructor();    private __prepareVariables;    private __prepareMutablesActions;    private __initMutables;    private __prepareForLoop;    private __getLangTranslations;    private __prepareTranslations;    private __setTranslations;    private __getStyle;    private __getHtml;    private __prepareTemplate;    private __createStates;    private __getMaxId;    private __selectElementNeeded;    private __mapSelectedElement;    private __registerOnChange;    private __endConstructor;    private connectedCallback;    private __defaultValue;    private __upgradeAttributes;    private __listBoolProps;    private __upgradeProperty;    private __addEvents;    private __applyTranslations;    private __getTranslation;    getStateManagerName(): string | undefined;    private __subscribeState;    private attributeChangedCallback;    protected postCreation(): void;    private _unsubscribeState;}
interface DebuggerConfig {    writeCompiled?: boolean;}
declare enum MutableAction {    SET = 0,    CREATED = 1,    UPDATED = 2,    DELETED = 3}
interface IData {}
interface Data extends IData {}
declare class Coordinate implements Data {    x: number;    y: number;}
declare enum ColorTypes {    rgb = 0,    hex = 1,    rgba = 2,    unkown = 3}
declare class ColorData implements Data {    r: number;    g: number;    b: number;}
declare function attribute<T>(onChange: (arg: T) => void);
declare function attribute();
declare function mutable();
declare function mutable<T>(onChange: (arg: T, action: MutableAction, path: string, value: any) => void);
declare function IgnoreForceIdentifier();
declare function overrideView(target: any);
declare function Debugger(config: DebuggerConfig);

declare class AvFormElement<T> extends WebComponent implements DefaultComponent {
    /**
     * If true, the checkbox will be required
     */
    required: boolean;
    name: string;
    nullable: boolean;
    value: T;
    onValueChanged(): void;
}

declare class AvForm extends WebComponent implements DefaultComponent {
    /**
    * Show/Hide the loading animation
    */
    loading: boolean;
    method: string;
    action: string;
    use_event: boolean;
    _fields: {
        [key: string]: AvFormElement<any>;
    };
    _fieldEnter: AvFormElement<any>;
    private submitLastChild;
    submit(): any;
    subsribe(fieldHTML: AvFormElement<any>): void;
    protected postCreation(): void;
}

declare class AvFor extends WebComponent implements DefaultComponent {
    /**
     * Name of item inside loop
     */
    item: string;
    /**
     * Name of property to loop though
     */
    in: string;
    /**
     * Name of your index
     */
    index: string;
    template: string;
    private parent;
    parentIndex: number;
    parentFor: AvFor | undefined;
    private otherPart;
    private elementsByPath;
    private elementsRootByIndex;
    private forInside;
    private maxIndex;
    private mutableElement;
    private mutableActionArray;
    private mutableObjectArray;
    private mutableObjectName;
    constructor();
    private init;
    /**
     * key must be something like that [3]
     */
    private createForElement;
    /**
     * key must be something like that [3] or [3].name
     */
    private updateForElement;
    /**
     * key must be something like that [3]
     */
    private deleteForElement;
    private reset;
    protected postCreation(): void;
    getParentKey(): string;
    updateIndexes(indexName: any, indexValue: any): void;
    private getAllIndexes;
}

declare abstract class DisplayElement<T extends Data> extends WebComponent implements DefaultComponent {
    currentInstance: T & SocketRAMManagerObject;
    eventsFunctions: {
        [key: string]: (data: T & SocketRAMManagerObject) => void;
    };
    protected abstract displayInfos(newData: T & SocketRAMManagerObject): any;
    protected onDeleteFunction(data: T & SocketRAMManagerObject): void;
    protected onUpdateFunction(data: T & SocketRAMManagerObject): void;
    protected destroy(): void;
    protected subscribeToInstance(): void;
    protected unsubscribeFromInstance(): void;
    /**
     * Assign a new instance to the component
     * @param {T & SocketRAMManagerObject} newInstance - The new instance to display
     */
    protected switchInstance(newInstance: T & SocketRAMManagerObject): void;
}

// end region js //
// region css //
{"display-element":[],"av-for":[],"av-form":[],"av-form-element":[]}
// end region css //
// region html //
{"display-element":{"name":"display-element","description":"","attributes":{}},"av-for":{"name":"av-for","description":"Generate a loop","attributes":{"item":{"name":"item","description":"Name of item inside loop","values":[]},"in":{"name":"in","description":"Name of property to loop though","values":[]},"index":{"name":"index","description":"Name of your index","values":[]}}},"av-form":{"name":"av-form","description":"","attributes":{"loading":{"name":"loading","description":"Show/Hide the loading animation","values":[]},"method":{"name":"method","description":"","values":[]},"action":{"name":"action","description":"","values":[]},"use_event":{"name":"use_event","description":"","values":[]}}},"av-form-element":{"name":"av-form-element","description":"","attributes":{"required":{"name":"required","description":"If true, the checkbox will be required","values":[]},"name":{"name":"name","description":"","values":[]},"nullable":{"name":"nullable","description":"","values":[]}}}}
// end region html //

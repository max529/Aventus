import { DtPointer, DtPointerTracker } from "./pointer.lib.avt";

export class AvGesture extends WebComponent implements DefaultComponent {

    //#region static

    //#endregion


    //#region props
    /**
     * The minimum scale value
     */
    @attribute()
    min_scale: number = 1;

    /**
     * The max scale allowed
     */
    @attribute()
    max_scale: number = 5;

    /**
     * If true, the drag and drop and zoom will be activated
     */
    @attribute((target: AvGesture) => {

    })
    is_enable: boolean = false;

    /**
     * If true, the event will be prevented from escalating to the parent
     */
    @attribute()
    stop_scroll_escalation: boolean = false;
    //#endregion


    //#region variables
    private cachedSvg: SVGSVGElement;
    private target: HTMLElement;
    private transform: DOMMatrix;
    private timerWillChange: number;
    private childrenTargets: HTMLElement[];
    private pointerTracker: DtPointerTracker;
    private currentPointers: DtPointer[];
    private previousPointers: DtPointer[];
    // value use to start calculation touch
    private positioningElRect: DOMRect;
    private startTranslate: Coordinate;
    private onMove: (values: {scale: number, x: number, y: number}) => void;

    //#endregion


    //#region states

    //#endregion


    //#region constructor

    //#endregion


    //#region methods
    protected override postCreation(): void {
        this.createElementNeeded();
    }

    // Need to be the same element that the transformation will be applied to !
    /**
     * Set the target element to which apply the transformation
     * @param {HTMLElement} element - The new target for the transformations
     */
    setTarget(element: HTMLElement): void {
        this.target = element;
        this.dispatchEvent(new CustomEvent("targetChanged"));

        this.applyMatrix({
            scale: 1,
            x: 0,
            y: 0
        });
    }

    setChildTarget(element: HTMLElement): void {
        this.childrenTargets.push(element);
    }

    /**
     * Manually trigger the value correction
     */
    resetPosition(): void {
        const matrix = this.createMatrix();
        this.applyMatrix(matrix);
    }

    private getSvg(): SVGSVGElement {
        if (!this.cachedSvg) {
            this.cachedSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        }

        return this.cachedSvg;
    }

    private createMatrix(): DOMMatrix {
        return this.getSvg().createSVGMatrix();
    }

    private getMidPoint(a: DtPointer, b: DtPointer): { clientX: number, clientY: number; } {
        if(!b) return a;

        return {
            clientX: (a.clientX + b.clientX) / 2,
            clientY: (a.clientY + b.clientY) / 2,
        };
    }

    private getDistance(a: DtPointer, b: DtPointer): number {
        if(!b) return 0;

        return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);
    }

    private applyMatrix(matrix: DOMMatrix | { scale: number, x: number, y: number }): void {
		let newScale: number;
		let newX: number;
		let newY: number;

		if (matrix instanceof DOMMatrix) {
			newScale = matrix.a || 1;
		} else {
			newScale = matrix.scale || 1;
		}

		if (matrix instanceof DOMMatrix) {
			newX = matrix.e || 0;
			newY = matrix.f || 0;
		} else {
			newX = matrix.x || 0;
			newY = matrix.y || 0;
		}

        const valuesCorrected: {scale: number, x: number, y: number} = this.correctValues(newScale, newX, newY);

        this.transform.e = valuesCorrected.x;
        this.transform.f = valuesCorrected.y;
        this.transform.d = this.transform.a = valuesCorrected.scale;

        if(this.timerWillChange != undefined) {
            clearTimeout(this.timerWillChange);
        }
        this.target.style.setProperty("--gesture-change", 'transform, width, height');
        this.timerWillChange = setTimeout(() => {
            this.target.style.setProperty("--gesture-change", "auto");
        }, 500);
        this.target.style.setProperty("--gesture-x", valuesCorrected.x + "px");
        this.target.style.setProperty("--gesture-y", valuesCorrected.y + "px");
        this.target.style.setProperty("--gesture-scale", valuesCorrected.scale + "");

        this.childrenTargets.forEach(child => {
            child.style.setProperty("--gesture-x", valuesCorrected.x + "px");
            child.style.setProperty("--gesture-y", valuesCorrected.y + "px");
            child.style.setProperty("--gesture-scale", valuesCorrected.scale + "");
        });

        this.dispatchEvent(new CustomEvent("onMove", {
            detail: {
                x: valuesCorrected.x,
                y: valuesCorrected.y,
                scale: valuesCorrected.scale,
            }
        }));
        this.onMove(valuesCorrected);
    }

    private createElementNeeded(): void {
        if (this.onMove === undefined) {
            this.onMove = () => {
            };
        }
        this.transform = this.createMatrix();
        this.pointerTracker = new DtPointerTracker(this, {
            start: (pointer, event) => {
                if (!this.is_enable) return false;

                if (this.pointerTracker.getCurrentPointers().length === 2 || !this.target)
                    return false;

                if (this.pointerTracker.getCurrentPointers().length === 0) {
                    this.positioningElRect = this.target.getBoundingClientRect();

                    this.startTranslate = {
                        x: this.x(),
                        y: this.y()
                    };
                   // this.animationInstance.start();
                }
                if (this.pointerTracker.getCurrentPointers().length === 1) {
                    this.previousPointers = undefined;
                    this.currentPointers = undefined;
                    this.positioningElRect = this.target.getBoundingClientRect();
                    this.startTranslate = {
                        x: this.x(),
                        y: this.y()
                    };
                    let customEvent: CustomEvent = new CustomEvent("twopointers");
                    this.dispatchEvent(customEvent);
                }
                return true;
            },
            move: () => {
                this.currentPointers = JSON.parse(JSON.stringify(this.pointerTracker.getCurrentPointers()));
            },
            end: () => {
                if (this.pointerTracker.getCurrentPointers().length === 0) {
                    //this.animationInstance.stop();
                } else if (this.pointerTracker.getCurrentPointers().length === 1) {
                    this.previousPointers = undefined;
                    this.currentPointers = undefined;
                    this.positioningElRect = this.target.getBoundingClientRect();
                    this.startTranslate = {
                        x: this.x(),
                        y: this.y()
                    };
                }
            }
        });
        /*this.animationInstance = new DtAnimation({
            animate: () => {
                //#region check everythink ok
                if (!this.target || !this.currentPointers) {
                    return;
                }

                if (this.previousPointers === undefined) {
                    this.previousPointers = JSON.parse(JSON.stringify(this.currentPointers));
                    return;
                }

                if (this.previousPointers.length < 1) return;
                if (this.currentPointers.length < 1) return;

                if (this.previousPointers[0].clientX === this.currentPointers[0].clientX && this.previousPointers[0].clientY === this.currentPointers[0].clientY) {
                    return;
                }

                if (this.previousPointers.length > 1 && this.currentPointers.length > 1) {
                    if (this.previousPointers[1].clientX === this.currentPointers[1].clientX && this.previousPointers[1].clientY === this.currentPointers[1].clientY) {
                        return;
                    }
                }
                //#endregion


                const prevMidpoint = this.getMidPoint(this.previousPointers[0], this.previousPointers[1]);
                const newMidpoint = this.getMidPoint(this.currentPointers[0], this.currentPointers[1]);

                const originX = prevMidpoint.clientX - (this.positioningElRect.left + this.x() - this.startTranslate.x);
                const originY = prevMidpoint.clientY - (this.positioningElRect.top + this.y() - this.startTranslate.y);

                const prevDistance = this.getDistance(this.previousPointers[0], this.previousPointers[1]);
                const newDistance = this.getDistance(this.currentPointers[0], this.currentPointers[1]);
                let scaleDiff = prevDistance ? newDistance / prevDistance : 1;

                const panX = newMidpoint.clientX - prevMidpoint.clientX;
                const panY = newMidpoint.clientY - prevMidpoint.clientY;

                let oldScale = this.scale();
                let newScale = oldScale * scaleDiff;
                newScale = this.correctValues(newScale, this.x(), this.y()).scale;
                scaleDiff = newScale / oldScale;

                const matrix = this.createMatrix().translate(panX, panY).translate(originX, originY).translate(this.x(), this.y()).scale(scaleDiff).translate(-originX, -originY).scale(this.scale());

                this.applyMatrix(matrix);

                this.previousPointers = this.currentPointers;
            },
            stopped: () => {
                this.previousPointers = undefined;
                this.currentPointers = undefined;
                if (this.target !== undefined) {
                    let customEvent = new CustomEvent("endpointers");
                    this.dispatchEvent(customEvent);
                }
            }
        });*/
        this.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!this.is_enable) return;
            if (this.stop_scroll_escalation) {
                e.stopPropagation();
            }
            // TODO: Dropdown close
            /*if (window.DtDropdownOpened) {
                window.DtDropdownOpened.expanded = false;
            }*/

            let targetCoordinates = this.target.getBoundingClientRect();
            let mousePositionRelativeToTarget = {
                x: e.pageX - targetCoordinates.x,
                y: e.pageY - targetCoordinates.y
            }

            let factor = 0.9;
            if (e.deltaY < 0) {
                factor = 1.1;
            }
            let oldScale = this.scale();
            let newScale = oldScale * factor;
            newScale = this.correctValues(newScale, this.x(), this.y()).scale;
            let scaleDiff = newScale / oldScale;
            const matrix = this.createMatrix()
                .translate(this.x(), this.y())
                .translate(mousePositionRelativeToTarget.x, mousePositionRelativeToTarget.y)
                .scale(scaleDiff)
                .translate(-mousePositionRelativeToTarget.x, -mousePositionRelativeToTarget.y)
                .scale(this.scale());
            this.applyMatrix(matrix);
        });
    }

    /**
     * Correct the values passed in parameters and return them
     * @override
     * @param {int} scale - The scale to correct
     * @param {int} x - The x position to correct
     * @param {int} y - The y position to correct
     * @returns {Object} - An object container the corrected values
     */
	private correctValues(scale: number, x: number, y: number): { scale: number, x: number, y: number } {
		scale = Math.max(this.min_scale, Math.min(this.max_scale, scale))
		return {
			scale: scale,
			x: x,
			y: y
		};
	}

    x(): number {
        return this.transform.e;
    }

    y(): number {
        return this.transform.f;
    }

    scale(): number {
        return this.transform.a;
    }
	//#endregion

}
export class DtPointer {
    public readonly id: number;
    private nativePointer: MouseEvent | PointerEvent | Touch;
    private pageX: number;
    private pageY: number;
    public readonly clientX: number;
    public readonly clientY: number;

    constructor(nativePointer: MouseEvent | PointerEvent | Touch) {
        this.id = -1;
        this.nativePointer = nativePointer;
        this.pageX = nativePointer.pageX;
        this.pageY = nativePointer.pageY;
        this.clientX = nativePointer.clientX;
        this.clientY = nativePointer.clientY;

        if (self.Touch && nativePointer instanceof Touch) {
            this.id = nativePointer.identifier;
        } else if (self.PointerEvent && nativePointer instanceof PointerEvent) {
            this.id = nativePointer.pointerId;
        }
    }
}

export class DtPointerTracker {
    private element: HTMLElement;
    private currentPointers: DtPointer[];
    private startCallback: (pointer?: DtPointer, event?: PointerEvent | TouchEvent) => boolean;
    private moveCallback: (previousPointer?: DtPointer[], trackedChangedPointers?: DtPointer[], event?: MouseEvent | TouchEvent) => void;
    private endCallback: (pointer?: DtPointer, event?: PointerEvent | TouchEvent) => void;
    private lastEvent: Date;

    constructor(element: HTMLElement, callbacks: {
        start?: (pointer?: DtPointer, event?: PointerEvent | TouchEvent) => boolean;
        move?: (previousPointer?: DtPointer[], trackedChangedPointers?: DtPointer[], event?: MouseEvent | TouchEvent) => void;
        end?: (pointer?: DtPointer, event?: PointerEvent | TouchEvent) => void;
    }) {
        this.element = element;
        this.currentPointers = [];
        const {
            start = () => true,
            move = () => {},
            end = () => {}
        } = callbacks;
        this.startCallback = start;
        this.moveCallback = move;
        this.endCallback = end;
        this.pointerStart = this.pointerStart.bind(this);
        this.touchStart = this.touchStart.bind(this);
        this.triggerPointerStart = this.triggerPointerStart.bind(this);
        this.move = this.move.bind(this);
        this.triggerPointerEnd = this.triggerPointerEnd.bind(this);
        this.pointerEnd = this.pointerEnd.bind(this);
        this.touchEnd = this.touchEnd.bind(this);
        this.lastEvent = new Date();


        this.element.addEventListener('mousedown', this.pointerStart);
        this.element.addEventListener('touchstart', this.touchStart);
    }

    reset(): void {
        this.currentPointers = [];
        window.removeEventListener('mousemove', this.move);
        window.removeEventListener('mouseup', this.pointerEnd);
        window.removeEventListener('touchmove', this.move);
        window.removeEventListener('touchend', this.touchEnd);
    }

    getCurrentPointers(): DtPointer[] {
        return this.currentPointers;
    }

    private triggerPointerStart(pointer: DtPointer, event: PointerEvent | TouchEvent): boolean {
        if (this.isTooOld()) {
            this.currentPointers = [];
        }

        if (!this.startCallback(pointer, event))
            return false;


        this.currentPointers.push(pointer);
        return true;
    }

    private pointerStart(event: PointerEvent): void {
        if (event.button !== 0)
            return;

        const oldPointersLength: number = this.currentPointers.length;
        if (!this.triggerPointerStart(new DtPointer(event), event))
            return;

        event.preventDefault();

        if (oldPointersLength === 0) {
            window.addEventListener('mousemove', this.move);
            window.addEventListener('mouseup', this.pointerEnd);
        }
    }

    private touchStart(event: TouchEvent): void {
        // TODO : close dropdown
       /* if (window.currentDropdownOpen) {
            window.currentDropdownOpen.expanded = false;
        }*/
        const oldPointersLength: number = this.currentPointers.length;

        for (const touch of Array.from(event.changedTouches)) {
            this.triggerPointerStart(new DtPointer(touch), event);
        }
        event.preventDefault();

        if (oldPointersLength === 0) {
            window.removeEventListener('touchmove', this.move);
            window.removeEventListener('touchend', this.touchEnd);

            window.addEventListener('touchmove', this.move);
            window.addEventListener('touchend', this.touchEnd);
        }
    }

    private move(event: MouseEvent | TouchEvent): void {
        setTimeout(() => {
            this.lastEvent = new Date();
            const previousPointers: DtPointer[] = this.currentPointers.slice();
            const changedPointers: DtPointer[] = ('changedTouches' in event) ? Array.from(event.changedTouches).map(t => new DtPointer(t)) : [new DtPointer(event)];
            const trackedChangedPointers: DtPointer[] = [];

            for (const pointer of changedPointers) {
                const index = this.currentPointers.findIndex(p => p.id === pointer.id);
                if (index === -1)
                    continue;

                trackedChangedPointers.push(pointer);
                this.currentPointers[index] = pointer;
            }

            if (trackedChangedPointers.length === 0)
                return;

            this.moveCallback(previousPointers, trackedChangedPointers, event);
        });
    }

    private triggerPointerEnd(pointer: DtPointer, event: PointerEvent | TouchEvent): boolean {
        const index: number = this.currentPointers.findIndex(p => p.id === pointer.id);
        if (index === -1)
            return false;

        this.currentPointers.splice(index, 1);
        this.endCallback(pointer, event);
        return true;
    }

    private pointerEnd(event: PointerEvent): void {
        event.preventDefault();
        if (this.currentPointers.length === 0) {
            window.removeEventListener('mousemove', this.move);
            window.removeEventListener('mouseup', this.pointerEnd);
        }
        if (!this.triggerPointerEnd(new DtPointer(event), event))
            return;
    }

    private touchEnd(event: TouchEvent): void {
        for (const touch of Array.from(event.changedTouches)) {
            this.triggerPointerEnd(new DtPointer(touch), event);
        }

        event.preventDefault();

        if (this.currentPointers.length === 0) {
            window.removeEventListener('touchmove', this.move);
            window.removeEventListener('touchend', this.touchEnd);
        }
    }

    private isTooOld(): boolean {
        let d: Date = new Date();
        let diff: number = d.getTime() - this.lastEvent.getTime();
        if (diff > 2000) {
            return true;
        }
        return false;
    }
}
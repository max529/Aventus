declare class AnimationManager {    static baseFps: number;    private options;    private nextFrame;    private fpsInterval;    private continueAnimation;    constructor(options: AnimationOptions);    private animate;    /**     * Start the of animation     */    start(): void;    /**     * Stop the animation     */    stop(): void;    /**     * Get the FPS     *     * @returns {number}     */    getFPS(): number;    /**     * Set the FPS     *     * @param fps     */    setFPS(fps: number): void;    /**     * Get the animation status (true if animation is running)     *     * @returns {boolean}     */    isStarted(): boolean;}
declare class Color {    private subscribers;    private currentColor;    static createFromRgb(r: number, g: number, b: number): Color;    /**     * The hex format of the color     */    get hex(): string;    set hex(hexString: string);    /**     * The rgb format of the color     */    get rgb(): ColorData;    set rgb(value: ColorData);    get r(): any;    set r(newValue: any);    get g(): any;    set g(newValue: any);    get b(): any;    set b(newValue: any);    /**     * Create a new color     */    constructor(colorString: string);    private getColorType;    private stringToRgb;    private hexStringToRgb;    private rgbToHex;    private onChange;    private offChange;    private emitEvent;}
declare class DateManager {}
declare class DragAndDrop {    private options;    private lastTargetHovered;    private pressManagerInstance;    private dragStartPosition;    private initialized;    private elementStartTranslate;    private cursorPositionRelativeToDraggableEl;    private shadowElement;    get strict(): boolean;    set strict(newValue: boolean);    constructor(options: DragAndDropOptions);    /**     * Check the integrity of the parametersd     */    private checkParameter;    /**     * Return the position of an event     * @param {PointerEvent} evt - mouseup, mousedown, mousemove, touchstart, touchend, touchmove event     * @returns {Coordinate} The coordinates of the event     */    private getEventPosition;    private getCurrentPosition;    /**     * Return the position of an element based of his translate style attribute     */    private getTranslatePosition;    /**     * Return the position of an element based off his absolute position     */    private getAbsolutePosition;    /**     * Get the position of an element based of his css vars     */    private getCssVarPosition;    private initDragAndDrop;    private destroyPressManager;    private startDragndrop;    /**     * Drag the element to match mouse/touch position     * @param {MouseEvent|TouchEvent} evt - mousemove / touchmove event     */    private draggingElement;    /**     * Drop the element to the current position, start position check if needed     * */    private droppingElement;    /**     * Check if the element is in on of the targets of the targets list     * @param {boolean} strict - If true, return true if the element touch the target (not contained into)     * @returns {Reponse} The operation response, return the node the element was the closest to if strict = false     */    private checkIfInTargets;    /**     * Check if element is in target     * @param {HTMLElement} element - The element to check     * @param {HTMLElement} target - The target to check     * @param {boolean} strict - If true, we check if the element touch the target (not contained)     */    private checkIfInTarget;    /**     * Correct the margin of the draggable element to match the target dimension     * */    private correctTranslate;    /**     * Set element margin     * @param {HTMLElement} element - The element to set coordinate     * @param {Coordinates} coordinate - The X and Y value     */    private setTransformPositionOffset;    /**     * Set the offset to apply to an element     * @param {HTMLElement} element - The element to set the offset of     * @param {Object} coordinate - The x and y value     */    private setAbsolutePositionOffset;    private setPositionOffset;    /**     * Set the blockOutsideTarget parameter     * @param {boolean} newBlockOutsideTarget - The new parameter value     */    setBlockOutsideTarget(newValue: boolean): void;    /**     * Set the autoCorrectPosition parameter     * @param {boolean} newAutoCorrectPosition - The new parameter value     */    setAutoCorrectPosition(newAutoCorrectPosition: boolean): void;    /**     * Set the targets of the drag and drop     * @param {HTMLElement[]} newTargets - The new drag and drop targets     */    setTargets(newTargets: HTMLElement[]): void;    /**     * Set the after drop event function     * @param {Function} newFunction - The function to trigger when element is dropped     */    setAfterDrop(newFunction: Function): void;    /**     * Return if the element is in one of the targets     * @param {boolean} strict - If true, check if the element is entierely in the target. Default to true     * @returns {Response} Return response.sucess false if outside, true otherwise. Response.value contains the target in which the element is, if any.     */    isInTarget(strict?: boolean): {        success: boolean;        value?: HTMLElement;    };    /**     * Get the current target     * @returns {Element} - The current target     */    getCurrentTarget(): HTMLElement;    /**     * Set the offsets in percentage     * @param {number} x - The X coordinate     * @param {number} y - The Y coordinate     */    setOffsetsPercents(coordinate: Coordinate): void;    /**     * Destroy the drag and drop events     */    destroy(): void;}

declare interface Event {
    normalize: () => void;
}
declare interface Object {
    transformIntoWatcher: (obj, onDataChanged) => any;
    prepareByPath:(obj, path, currentPath = "") => {canApply:boolean, objToApply:any};
    isPathMatching:(p1:string, p2:string) => void;
}

declare class PointerTracker {    private element;    private currentPointers;    private startCallback;    private moveCallback;    private endCallback;    private lastEvent;    constructor(element: any, callbacks: any);    reset(): void;    private createPointer;    private triggerPointerStart;    private pointerStart;    private touchStart;    private move;    private triggerPointerEnd;    private pointerEnd;    private touchEnd;    private isTooOld;}
declare class PressManager {    private options;    private listenerPointerUp;    private listenerPointerMove;    private listenerPointerDown;    private startPosition;    private timeoutLongPress;    private mouseDownEvent;    private notPress;    /**     * @param {*} options - The options     * @param {HTMLElement} options.element - The element to manage     */    constructor(options: PressManagerOptions);    destroy(): void;    private pointerUpFunction;    private pointerMoveFunction;    private pointerDownFunction;}
declare class AvResizeObserver {    private callback;    private targets;    private static resizeObserverCallbacks;    private static resizeObserverInstance;    constructor(callback: () => void);    observe(target: ResizeObserverElement): void;    /**     * Disconnect the observer.     */    disconnect(): void;}
declare class ResourceLoader {    private waitingResources;    load(options: ResourceLoaderOptions, preventCache?: boolean): void;}
declare class Socket implements Socket {    private options;    private waitingList;    private multipltWaitingList;    private onDone;    private timeoutError;    private memoryBeforeOpen;    private nbClose;    private socket;    private constructor();    init(options?: SocketOptions): void;    private static __instances;    static getInstance(name?: string): Socket;    addRoute(newRoute: SocketRoute): void;    /**     * The route to remove     * @param route - The route to remove     */    removeRoute(route: SocketRoute): void;    open(done?: Function, error?: Function): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param options the options to add to the message (typically the uid)     */    sendMessage(channelName: string, data?: any, options?: {}): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWait(channelName: string, data: {}, callbacks: {}): void;    /**     *     * @param channelName The channel on which the message is sent     * @param data The data to send     * @param callbacks The callbacks to call. With the channel as key and the callback function as value     */    sendMessageAndWaitMultiple(channelName: string, data: {}, callbacks: {}): void;    private onOpen;    private onError;    private onClose;    private onMessage;    private log;}
declare abstract class SocketRAMManager<T extends Data> implements RAMManager {    types: {        [key: string]: string;    };    options: {        definition?: {            [key: string]: string;        };    };    private records;    private gotAllRecords;    private objectProperties;    private socketActions;    private socketRoutes;    private subscribers;    private registeredErrorsCallbacks;    abstract getObjectName(): string;    getPrimaryKey(): string;    private _getSocketName;    constructor();    addErrorListener(callback: any): void;    triggerError(...args: {}): void;    getAll(): Promise<(T & SocketRAMManagerObject)[]>;    get(id: number, forceRefresh?: boolean): Promise<T & SocketRAMManagerObject>;    getMultiple(ids: number[]): Promise<(T & SocketRAMManagerObject)[]>;    create(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    update(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    delete(data: T | T[], cbError?: Function): Promise<T & SocketRAMManagerObject>;    subscribeMultiple(callback: Function, types?: string[]): void;    unsubscribeMultiple(callback: Function, types?: string[]): void;    subscribe(callback: Function): void;    unsubscribe(callback: Function): void;    onUpdated(callback: Function): void;    offUpdated(callback: Function): void;    onDeleted(callback: Function): void;    offDelete(callback: Function): void;    private addSubscriber;    private removeSubscriber;    private printErrors;    private publish;    private addDatabaseOperationsToRecord;    private formatResponse;    private addDataToRecords;    private addMemoryRecord;    private deleteMemoryRecord;    private convertDataToDefinition;    private convertDefinitionToData;    private updateObjectProperties;    private updateInstanceData;    private manageMultipleRecords;    private isDataContainsMultipleRecords;}
declare class StateManager {    logLevel: number;    _activeState: any;    _activeParams: any;    _activeSlug: any;    _callbackList: {};    _subscribersMutliple: {};    _subscribers: {};    _isNumberRegex: {};    _callbackFunctions: {};    private constructor();    private static __instances;    static getInstance(name?: string): StateManager;    subscribe(state: string | string[], callbacks: ComponentState): void;    /**     *     * @param {string|Array} state - The state(s) to unsubscribe from     * @param {Object} callbacks     * @param {activeCallback} [callbacks.active]     * @param {incativeCallback} [callbacks.inactive]     * @param {askChangeCallback} [callbacks.askChange]     */    unsubscribe(state: any, callbacks: any): void;    /**     * Format a state and return if you need to bypass the test or not     * @param {string} string - The state to format     * @returns {Object} - The state, the formated state and if it's a regex state or not     */    _prepareStateString(string: any): {        state: any;        stateToTest: any;        bypassTest: boolean;    };    /**     * Escape a string to be regex-compatible ()     * @param {string} string The string to escape     * @returns An escaped string     */    _escapeRegExp(string: any): any;    /**     * Get the slug from a state string     * @param {string} state The state to extract the slug from     * @returns {string|undefined} The slug of the state or undefined if the state don't have one     */    _getSlugFromState(state: any): any;    /**     * Save the current info (state/params) in cache     */    _saveDataInCache(): void;    /**     * Add a callback to a key     * @param {string} key - The key to trigger to trigger the function     * @param {function} callback - The function to trigger     */    addFunction(key: any, callback: any): void;    /**     * Remove a function from a key     * @param {string} key - The key to remove the function from     * @param {function} callback - The function to remove     */    removeFunction(key: any, callback: any): void;    /**     * Trigger all the functions added under a key     * @param {string} key - The key to trigger     * @param {*} [params] - The params to pass to the functions (optional)     */    triggerFunction(key: any, params?: {}): void;    /**     * Remove all the function added under all keys     */    clearFunctions(): void;    /**     * Set the current active state     * @param {string} state - The state to set to active     * @param {number} slug - The slug of the active state (Only work if the state ends with "*")     * @param {Object} params - The params of the active state     */    setActiveState(state: any, params?: {}): void;    /**     * Get the active state     * @returns {string} - The active state     */    getActiveState(): any;    /**     * Get the active params     * @returns {Object} - The active params     */    getActiveParams(): any;    /**     * Get the active slug     * @returns {int} - The active slug     */    getActiveSlug(): any;    /**     * Check if a state is in the subscribers and active, return true if it is, false otherwise     * @param {string} state - The state to test     * @returns {boolean} - True if the state is in the subscription list and active, false otherwise     */    isStateActive(state: any): boolean;    _log(logMessage: any, type: any): void;}
declare class Utils {    /**     * Get the position of an element on the screen     * @param {HTMLElement} el - The element to get the position from     * @returns {Object} - The coordinates of the element on the screen     */    static getPositionOnScreen(el: HTMLElement): {        top: number;        left: number;    };    /**     * Find the first parent of the element which nodename match the tagname     * @param {string} tagname - The tagname to find     * @param {HTMLElement} el - The element to start from     * @returns {null|HTMLElement} - The first element found or null if none found     */    static findParent(tagname: any, el: any, untilNode?: any): Element | undefined;    /**     * Find all parent of the element which nodename match the tagname     * @param {string} tagname - The tagname to find     * @param {HTMLElement} el - The element to start from     * @param {HTMLElement} untilNode - The element to end     * @returns {HTMLElement[]} - The elements found     */    static findParents(tagname: any, el: any, untilNode?: any): {};}
declare class WebComponent extends HTMLElement implements DefaultComponent {    static get observedAttributes(): {};    private _first;    private _isReady;    get isReady(): boolean;    private _translations;    private currentState;    private statesList;    private _components;    private __onChangeFct;    private getSlugFct;    private __mutable;    private __mutableActions;    private __prepareForCreate;    private __prepareForUpdate;    private __loopTemplate;    constructor();    private __prepareVariables;    private __prepareMutables;    private __prepareForLoop;    private __getLangTranslations;    private __prepareTranslations;    private __setTranslations;    private __getStyle;    private __getHtml;    private __prepareTemplate;    private __createStates;    private __getMaxId;    private __selectElementNeeded;    private __mapSelectedElement;    private __registerOnChange;    private __endConstructor;    private connectedCallback;    private __defaultValue;    private __upgradeAttributes;    private __listBoolProps;    private __upgradeProperty;    private __addEvents;    private __applyTranslations;    private __getTranslation;    getStateManagerName(): string | undefined;    private __subscribeState;    private attributeChangedCallback;    protected postCreation(): void;    private _unsubscribeState;}
declare function attribute<T>(onChange: (arg: T) => void);
declare function attribute();
declare function mutable();
declare function mutable<T>(onChange: (arg: T, action: MutableAction, path: string, value: any) => void);
declare function IgnoreForceIdentifier();
declare function overrideView(target: any);
declare function Debugger(config: DebuggerConfig);
declare class ColorData implements Data {    r: number;    g: number;    b: number;}
declare enum ColorTypes {    rgb = 0,    hex = 1,    rgba = 2,    unkown = 3}
interface ComponentState extends IData {    active?: (activeState: string) => void;    inactive?: (oldState: string, nextState: string) => void;    askChange?: (activeState: string, nextState: string) => boolean;    getSlug?: () => string;}
interface ComponentStates extends IData {    [key: string]: ComponentState;}
interface DebuggerConfig extends IData {    writeCompiled?: boolean;}
interface DefaultComponent extends IData {    states?: ComponentStates;    [key: string]: any;    getStateManagerName?(): string;}
declare class Coordinate implements Data {    x: number;    y: number;}
interface Data extends IData {}
interface IData {}
interface ResizeObserverElement extends Element, IData {    sourceIndex: string | undefined;}
declare class Device implements Data {    static get os(): DeviceType;}
declare enum DeviceType {    RaspberryOS = 0,    IpadOS = 1,    Other = 2}
interface DragAndDropCssVars extends IData {    top: number;    left: number;}
interface DragAndDropOptions extends IData {    element: HTMLElement;    elementTrigger?: HTMLElement;    targets?: HTMLElement[];    blockOutsideTarget?: boolean;    autoCorrectPosition?: boolean;    strict?: boolean;    shadow?: boolean;    zoom?: number;    useAbsolute?: boolean;    cssVars?: DragAndDropCssVars;    dropCallback?: Function;    onMove?: Function;    onStart?: (e: MouseEvent) => void;    onEnd?: (e: PressManagerEvent, instance: DragAndDrop) => void;    onDragStart?: (e: PointerEvent, instance: DragAndDrop, shadowElement: HTMLElement) => void;    onPressStop?: (e: PressManagerEvent) => void;    customSetPosition?: Function;    classesToAdd?: String;    offsetDrag?: number;    ignoreDragElement?: boolean;    refreshTargets?: Function;    offsetsPercents?: {        x: number;        y: number;    };    usePercent?: boolean;    useTargetZoom?: Function;    authorizeDrag?: Function;    getZoom?: Function;    afterDrop?: Function;}
interface Pointer extends IData {    id: number;    constructor(nativePointer: Touch | PointerEvent): any;}
interface PressManagerEvent extends MouseEvent, IData {    details?: {        element: Element;        mousedownEvent: MouseEvent;    };}
interface PressManagerOptions extends IData {    element: Element;    onStart?: (e: MouseEvent) => void;    onStop?: (e: MouseEvent) => void;    onPress?: (e: PressManagerEvent, self: PressManager) => void;    onLongPress?: (e: MouseEvent, self: PressManager) => void;    onDrag?: (e: MouseEvent, coordinate: Coordinate) => void;    offsetDrag?: number;    delay?: number;    disableDrag?: boolean;}
interface RAMManager extends IData {}
interface SocketRAMManagerObject extends IData {    update(newData: {}): Promise<{}>;    onUpdate(callback: Function): any;    offUpdate(callback: Function): any;    delete(): any;    onDelete(callback: Function): any;    offDelete(callback: Function): any;    _publish(type: any, data: any): any;    _subscribers: {        updated: Function[];        deleted: Function[];    };}
interface ResourceLoaderOptions extends IData {    url: string;    success?: (data: any) => void;    error?: (error: any) => void;}
interface SocketMessage extends IData {    channel: string;    data?: any;}
interface SocketOptions extends IData {    log?: boolean;    ip?: string;    port?: number;    routes?: {        [key: string]: SocketRoute[];    };    socketName?: string;    onOpen?: () => void;    onError?: () => void;    onClose?: () => void;}
interface SocketRoute extends IData {    channel: string;    callback: (data: any) => void;}
declare enum MutableAction {    CREATED = 0,    UPDATED = 1,    DELETED = 2}

declare abstract class DisplayElement<T extends Data> extends WebComponent implements DefaultComponent {
    currentInstance: T & SocketRAMManagerObject;
    eventsFunctions: {
        [key: string]: (data: T & SocketRAMManagerObject) => void;
    };
    protected abstract displayInfos(newData: T & SocketRAMManagerObject): any;
    protected onDeleteFunction(data: T & SocketRAMManagerObject): void;
    protected onUpdateFunction(data: T & SocketRAMManagerObject): void;
    protected destroy(): void;
    protected subscribeToInstance(): void;
    protected unsubscribeFromInstance(): void;
    /**
     * Assign a new instance to the component
     * @param {T & SocketRAMManagerObject} newInstance - The new instance to display
     */
    protected switchInstance(newInstance: T & SocketRAMManagerObject): void;
}

declare class AvFor extends WebComponent implements DefaultComponent {
    item: string;
    in: string;
    index: string;
    template: string;
    private parent;
    private proxyElement;
    private elementsByPath;
    private elementsRootByIndex;
    private forInside;
    private maxIndex;
    parentKey: string;
    parentFor: AvFor | undefined;
    private regexNumberLoop;
    constructor();
    private init;
    /**
     * key must be something like that [3]
     */
    private createForElement;
    /**
     * key must be something like that [3] or [3].name
     */
    private updateForElement;
    /**
     * key must be something like that [3]
     */
    private deleteForElement;
    protected postCreation(): void;
    private getAllIndexes;
}

